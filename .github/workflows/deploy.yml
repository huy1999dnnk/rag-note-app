name: Build and Deploy to AWS EC2

on:
  push:
    branches: [main]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata for Docker images
        id: meta
        run: |
          echo "sha_short=$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_OUTPUT
          echo "timestamp=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Build and push Backend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/note-app:backend-latest,${{ secrets.DOCKER_USERNAME }}/note-app:backend-${{ steps.meta.outputs.sha_short }}

      - name: Build and push Frontend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/note-app:frontend-latest,${{ secrets.DOCKER_USERNAME }}/note-app:frontend-${{ steps.meta.outputs.sha_short }}

      - name: Create environment files locally
        run: |
          # Create backend .env file
          cat > backend/.env << EOF
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_HOST=db
          POSTGRES_PORT=5432

          REDIS_HOST=redis
          REDIS_PORT=6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          REDIS_DB=0

          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_BUCKET_NAME=${{ secrets.AWS_BUCKET_NAME }}


          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URI=${{ secrets.GOOGLE_REDIRECT_URI }}

          JWT_SECRET=${{ secrets.JWT_SECRET }}

          PASSWORD_RESET_CODE_EXPIRE_MINUTES=60
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          FRONTEND_URL_DEV=${{ secrets.FRONTEND_URL_DEV }}

          ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS }}
          EOF

          # Create frontend .env.production file
          cat > frontend/.env.production << EOF
          VITE_API_BASE_URL=""
          VITE_API_V1_URL="/api/v1"
          VITE_AUTH_API_URL="/api/auth"
          VITE_GOOGLE_AUTH_ENDPOINT=/api/auth/google/login
          EOF

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}

      - name: Add EC2 to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to EC2
        run: |
          # Create deployment directory on EC2
          ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "mkdir -p /home/${{ secrets.EC2_USER }}/task-management-app"

           # Transfer *only* necessary files (no source code needed since we're using pre-built images)
            rsync -avz \
            --exclude 'node_modules' --exclude '.git' --exclude '.github' \
            --include='backend/' \
            --include='backend/.env' \
            --include='backend/docker-compose.yml' \
            --include='frontend/' \
            --include='frontend/.env.production' \
            --include='frontend/nginx.conf' \
            --include='frontend/docker-compose.yml' \
            --include='app.sh' \
            --exclude='*' \
            ./ ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/home/${{ secrets.EC2_USER }}/task-management-app/

          # Create docker-compose override file on EC2 to use pre-built images
          ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            cd /home/${{ secrets.EC2_USER }}/task-management-app

            mkdir -p backend frontend
            
            # Create docker-compose.override.yml for backend
            cat > backend/docker-compose.override.yml << 'EOL'
            version: "3.8"
            services:
              app:
                image: ${{ secrets.DOCKER_USERNAME }}/note-app:backend-${{ steps.meta.outputs.sha_short }}
                pull_policy: always
              celery_worker:
                image: ${{ secrets.DOCKER_USERNAME }}/note-app:backend-${{ steps.meta.outputs.sha_short }}
                pull_policy: always
            EOL
            
            # Create docker-compose.override.yml for frontend
            cat > frontend/docker-compose.override.yml << 'EOL'
            version: "3.8"
            services:
              frontend:
                image: ${{ secrets.DOCKER_USERNAME }}/note-app:frontend-${{ steps.meta.outputs.sha_short }}
                pull_policy: always
            EOL
          EOF

          # Deploy on EC2
          ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            cd /home/${{ secrets.EC2_USER }}/task-management-app
            
            # Make app.sh executable
            chmod +x app.sh
            
            # Set up SSL certificates
            echo "Setting up SSL certificates..."
            sudo mkdir -p /etc/ssl/private /etc/ssl/certs
            sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
              -keyout /etc/ssl/private/nginx-selfsigned.key \
              -out /etc/ssl/certs/nginx-selfsigned.crt \
              -subj "/CN=${{ secrets.EC2_HOST }}"
            
            # Clean up old Docker resources
            docker system prune -af
            
            # Login to Docker Hub (to pull private images if needed)
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
            
            # Stop any running containers
            ./app.sh down
            
            # Pull and start containers using the pre-built images
            docker-compose -f ./backend/docker-compose.yml -f ./backend/docker-compose.override.yml pull
            docker-compose -f ./frontend/docker-compose.yml -f ./frontend/docker-compose.override.yml pull
            
            # Start the application in detached mode
            ./app.sh deploy -d
            
            # Print container status
            docker ps
          EOF
